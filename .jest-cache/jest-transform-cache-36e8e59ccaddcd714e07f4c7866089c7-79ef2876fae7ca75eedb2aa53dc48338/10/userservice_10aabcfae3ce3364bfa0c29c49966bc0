10854f9407e341eb8f138eb5f4d85118
"use strict";
/**
 * TDD Implementation: User Service
 *
 * Business logic layer for user management
 * Implements all functionality to pass tests in user.service.spec.ts
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserService = void 0;
const user_entity_1 = require("../entities/user.entity");
const errors_1 = require("@libs/errors");
const password_utils_1 = require("@libs/auth/password.utils");
const jwt_utils_1 = require("@libs/auth/jwt.utils");
const crypto_1 = require("crypto");
class UserService {
    userRepository;
    notificationService;
    constructor(userRepository, notificationService) {
        this.userRepository = userRepository;
        this.notificationService = notificationService;
    }
    /**
     * Register new user
     * TDD: Implements registration tests
     */
    async register(data) {
        // Validate password strength
        const passwordValidation = (0, password_utils_1.validatePasswordStrength)(data.password);
        if (!passwordValidation.valid) {
            throw new errors_1.BadRequestError(passwordValidation.errors.join(', '));
        }
        // Hash password
        const hashedPassword = await (0, password_utils_1.hashPassword)(data.password);
        // Generate email verification token
        const emailVerificationToken = this.generateToken();
        // Create user
        const user = await this.userRepository.createUser({
            email: data.email,
            password: hashedPassword,
            firstName: data.firstName,
            lastName: data.lastName,
            phoneNumber: data.phoneNumber,
            emailVerificationToken,
        });
        // Send verification email if notification service is available
        if (this.notificationService) {
            await this.notificationService.sendVerificationEmail(user.email, emailVerificationToken);
        }
        return { user };
    }
    /**
     * Login user
     * TDD: Implements login tests
     */
    async login(emailOrCredentials, password) {
        // Handle both signatures: login(email, password) and login({email, password})
        let credentials;
        if (typeof emailOrCredentials === 'string') {
            credentials = { email: emailOrCredentials, password: password };
        }
        else {
            credentials = emailOrCredentials;
        }
        // Find user by email
        const user = await this.userRepository.findByEmail(credentials.email);
        if (!user) {
            throw new errors_1.UnauthorizedError('Invalid credentials');
        }
        // Check if account is locked
        if (user.lockedUntil && user.lockedUntil > new Date()) {
            throw new errors_1.UnauthorizedError('Account is locked. Please try again later.');
        }
        // Check if account is suspended
        if (user.status === user_entity_1.UserStatus.SUSPENDED) {
            throw new errors_1.UnauthorizedError('Account is suspended');
        }
        // Verify password
        const isPasswordValid = await (0, password_utils_1.comparePassword)(credentials.password, user.password);
        if (!isPasswordValid) {
            // Increment login attempts
            await this.userRepository.incrementLoginAttempts(user.id);
            throw new errors_1.UnauthorizedError('Invalid credentials');
        }
        // Check if email is verified
        if (!user.emailVerifiedAt) {
            throw new errors_1.UnauthorizedError('Please verify your email before logging in');
        }
        // Reset login attempts on successful login
        await this.userRepository.resetLoginAttempts(user.id);
        // Update last login timestamp
        await this.userRepository.updateLastLogin(user.id);
        // Generate tokens
        const accessToken = (0, jwt_utils_1.generateAccessToken)({
            userId: user.id,
            email: user.email,
            role: user.role,
        });
        const refreshToken = (0, jwt_utils_1.generateRefreshToken)({
            userId: user.id,
            email: user.email,
            role: user.role,
        });
        return {
            user,
            accessToken,
            refreshToken,
            token: accessToken, // Alias for backward compatibility
        };
    }
    /**
     * Verify email with token
     * TDD: Implements verifyEmail tests
     */
    async verifyEmail(token) {
        return this.userRepository.verifyEmail(token);
    }
    /**
     * Resend verification email
     */
    async resendVerificationEmail(email) {
        const user = await this.userRepository.findByEmail(email);
        if (!user) {
            throw new errors_1.BadRequestError('User not found');
        }
        if (user.emailVerifiedAt) {
            throw new errors_1.BadRequestError('Email already verified');
        }
        // Generate new verification token
        const emailVerificationToken = this.generateToken();
        await this.userRepository.update(user.id, { emailVerificationToken });
        // Send verification email if notification service is available
        if (this.notificationService) {
            await this.notificationService.sendVerificationEmail(user.email, emailVerificationToken);
        }
    }
    /**
     * Request email change
     */
    async requestEmailChange(userId, newEmail) {
        // Verify user exists
        await this.userRepository.findById(userId);
        // Check if new email is already taken
        const existingUser = await this.userRepository.findByEmail(newEmail);
        if (existingUser && existingUser.id !== userId) {
            throw new errors_1.BadRequestError('Email already in use');
        }
        // Generate verification token for new email
        const verificationToken = this.generateToken();
        // Store the pending email change (in production, would store in database)
        // For now, we'll use the emailVerificationToken field
        await this.userRepository.update(userId, {
            emailVerificationToken: verificationToken,
        });
        // Send verification email to new address if notification service is available
        if (this.notificationService) {
            await this.notificationService.sendVerificationEmail(newEmail, verificationToken);
        }
        return verificationToken;
    }
    /**
     * Verify new email with token
     */
    async verifyNewEmail(verificationToken) {
        // In a real implementation, we would look up the pending email change by token
        // For now, we'll just verify the token exists
        const user = await this.userRepository.verifyEmail(verificationToken);
        return user;
    }
    /**
     * Request password reset
     * TDD: Implements requestPasswordReset tests
     */
    async requestPasswordReset(email) {
        const user = await this.userRepository.findByEmail(email);
        // Don't reveal if email exists (security best practice)
        if (!user) {
            return null;
        }
        const resetToken = this.generateToken();
        await this.userRepository.setPasswordResetToken(user.id, resetToken);
        return user;
    }
    /**
     * Reset password with token
     * TDD: Implements resetPassword tests
     */
    async resetPassword(token, newPassword) {
        // Validate new password
        const passwordValidation = (0, password_utils_1.validatePasswordStrength)(newPassword);
        if (!passwordValidation.valid) {
            throw new errors_1.BadRequestError(passwordValidation.errors.join(', '));
        }
        // Hash new password
        const hashedPassword = await (0, password_utils_1.hashPassword)(newPassword);
        // Reset password
        return this.userRepository.resetPassword(token, hashedPassword);
    }
    /**
     * Get user by ID
     * TDD: Implements getUserById tests
     */
    async getUserById(userId) {
        return this.userRepository.findById(userId);
    }
    /**
     * Update user profile
     * TDD: Implements updateProfile tests
     */
    async updateProfile(userId, data) {
        // Filter out sensitive fields that should not be updated directly
        const allowedFields = {
            firstName: data.firstName,
            lastName: data.lastName,
            phoneNumber: data.phoneNumber,
        };
        // Remove undefined values
        const updateData = Object.fromEntries(Object.entries(allowedFields).filter(([_, v]) => v !== undefined));
        return this.userRepository.update(userId, updateData);
    }
    /**
     * Change password (requires old password)
     * TDD: Implements changePassword tests
     */
    async changePassword(userId, oldPassword, newPassword) {
        // Get user
        const user = await this.userRepository.findById(userId);
        // Verify old password
        const isOldPasswordValid = await (0, password_utils_1.comparePassword)(oldPassword, user.password);
        if (!isOldPasswordValid) {
            throw new errors_1.UnauthorizedError('Current password is incorrect');
        }
        // Validate new password
        const passwordValidation = (0, password_utils_1.validatePasswordStrength)(newPassword);
        if (!passwordValidation.valid) {
            throw new errors_1.BadRequestError(passwordValidation.errors.join(', '));
        }
        // Hash new password
        const hashedPassword = await (0, password_utils_1.hashPassword)(newPassword);
        // Update password
        await this.userRepository.update(userId, { password: hashedPassword });
    }
    /**
     * Refresh access token
     * TDD: Implements refreshToken tests
     */
    async refreshToken(refreshToken) {
        // Verify refresh token
        const payload = (0, jwt_utils_1.verifyRefreshToken)(refreshToken);
        // Ensure user still exists and is active
        const user = await this.userRepository.findById(payload.userId);
        if (user.status !== user_entity_1.UserStatus.ACTIVE) {
            throw new errors_1.UnauthorizedError('Account is not active');
        }
        // Generate new access token
        const accessToken = (0, jwt_utils_1.generateAccessToken)({
            userId: user.id,
            email: user.email,
            role: user.role,
        });
        return { accessToken };
    }
    /**
     * Generate random token
     */
    generateToken() {
        return (0, crypto_1.randomBytes)(32).toString('hex');
    }
}
exports.UserService = UserService;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJmaWxlIjoiQzpcXEFkYXB0aXZlX1Rlc3RpbmdcXHNyY1xcc2VydmljZXNcXHVzZXItbWFuYWdlbWVudFxcc2VydmljZXNcXHVzZXIuc2VydmljZS50cyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7O0dBS0c7OztBQUdILHlEQUEyRDtBQUMzRCx5Q0FHc0I7QUFDdEIsOERBSW1DO0FBQ25DLG9EQUFxRztBQUNyRyxtQ0FBcUM7QUE0QnJDLE1BQWEsV0FBVztJQUVaO0lBQ0E7SUFGVixZQUNVLGNBQThCLEVBQzlCLG1CQUF5QjtRQUR6QixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDOUIsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFNO0lBQ2hDLENBQUM7SUFFSjs7O09BR0c7SUFDSCxLQUFLLENBQUMsUUFBUSxDQUFDLElBQWlCO1FBQzlCLDZCQUE2QjtRQUM3QixNQUFNLGtCQUFrQixHQUFHLElBQUEseUNBQXdCLEVBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ25FLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUM5QixNQUFNLElBQUksd0JBQWUsQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFDbEUsQ0FBQztRQUVELGdCQUFnQjtRQUNoQixNQUFNLGNBQWMsR0FBRyxNQUFNLElBQUEsNkJBQVksRUFBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7UUFFekQsb0NBQW9DO1FBQ3BDLE1BQU0sc0JBQXNCLEdBQUcsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1FBRXBELGNBQWM7UUFDZCxNQUFNLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDO1lBQ2hELEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztZQUNqQixRQUFRLEVBQUUsY0FBYztZQUN4QixTQUFTLEVBQUUsSUFBSSxDQUFDLFNBQVM7WUFDekIsUUFBUSxFQUFFLElBQUksQ0FBQyxRQUFRO1lBQ3ZCLFdBQVcsRUFBRSxJ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LENBQUM7SUFDekUsQ0FBQztJQUVEOzs7T0FHRztJQUNILEtBQUssQ0FBQyxZQUFZLENBQUMsWUFBb0I7UUFDckMsdUJBQXVCO1FBQ3ZCLE1BQU0sT0FBTyxHQUFHLElBQUEsOEJBQWtCLEVBQUMsWUFBWSxDQUFDLENBQUM7UUFFakQseUNBQXlDO1FBQ3pDLE1BQU0sSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLGNBQWMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRWhFLElBQUksSUFBSSxDQUFDLE1BQU0sS0FBSyx3QkFBVSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3RDLE1BQU0sSUFBSSwwQkFBaUIsQ0FBQyx1QkFBdUIsQ0FBQyxDQUFDO1FBQ3ZELENBQUM7UUFFRCw0QkFBNEI7UUFDNUIsTUFBTSxXQUFXLEdBQUcsSUFBQSwrQkFBbUIsRUFBQztZQUN0QyxNQUFNLEVBQUUsSUFBSSxDQUFDLEVBQUU7WUFDZixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7WUFDakIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1NBQ2hCLENBQUMsQ0FBQztRQUVILE9BQU8sRUFBRSxXQUFXLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQ7O09BRUc7SUFDSyxhQUFhO1FBQ25CLE9BQU8sSUFBQSxvQkFBVyxFQUFDLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN6QyxDQUFDO0NBQ0Y7QUF0VEQsa0NBc1RDIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbIkM6XFxBZGFwdGl2ZV9UZXN0aW5nXFxzcmNcXHNlcnZpY2VzXFx1c2VyLW1hbmFnZW1lbnRcXHNlcnZpY2VzXFx1c2VyLnNlcnZpY2UudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBUREQgSW1wbGVtZW50YXRpb246IFVzZXIgU2VydmljZVxuICpcbiAqIEJ1c2luZXNzIGxvZ2ljIGxheWVyIGZvciB1c2VyIG1hbmFnZW1lbnRcbiAqIEltcGxlbWVudHMgYWxsIGZ1bmN0aW9uYWxpdHkgdG8gcGFzcyB0ZXN0cyBpbiB1c2VyLnNlcnZpY2Uuc3BlYy50c1xuICovXG5cbmltcG9ydCB7IFVzZXJSZXBvc2l0b3J5IH0gZnJvbSAnLi4vcmVwb3NpdG9yaWVzL3VzZXIucmVwb3NpdG9yeSc7XG5pbXBvcnQgeyBVc2VyLCBVc2VyU3RhdHVzIH0gZnJvbSAnLi4vZW50aXRpZXMvdXNlci5lbnRpdHknO1xuaW1wb3J0IHtcbiAgVW5hdXRob3JpemVkRXJyb3IsXG4gIEJhZFJlcXVlc3RFcnJvcixcbn0gZnJvbSAnQGxpYnMvZXJyb3JzJztcbmltcG9ydCB7XG4gIGhhc2hQYXNzd29yZCxcbiAgY29tcGFyZVBhc3N3b3JkLFxuICB2YWxpZGF0ZVBhc3N3b3JkU3RyZW5ndGgsXG59IGZyb20gJ0BsaWJzL2F1dGgvcGFzc3dvcmQudXRpbHMnO1xuaW1wb3J0IHsgZ2VuZXJhdGVBY2Nlc3NUb2tlbiwgZ2VuZXJhdGVSZWZyZXNoVG9rZW4sIHZlcmlmeVJlZnJlc2hUb2tlbiB9IGZyb20gJ0BsaWJzL2F1dGgvand0LnV0aWxzJztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnY3J5cHRvJztcblxuZXhwb3J0IGludGVyZmFjZSBSZWdpc3RlckR0byB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG4gIGZpcnN0TmFtZTogc3RyaW5nO1xuICBsYXN0TmFtZTogc3RyaW5nO1xuICBwaG9uZU51bWJlcj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dpbkR0byB7XG4gIGVtYWlsOiBzdHJpbmc7XG4gIHBhc3N3b3JkOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9naW5SZXNwb25zZSB7XG4gIHVzZXI6IFVzZXI7XG4gIGFjY2Vzc1Rva2VuOiBzdHJpbmc7XG4gIHJlZnJlc2hUb2tlbjogc3RyaW5nO1xuICB0b2tlbjogc3RyaW5nOyAvLyBBbGlhcyBmb3IgYWNjZXNzVG9rZW5cbn1cblxuZXhwb3J0IGludGVyZmFjZSBVcGRhdGVQcm9maWxlRHRvIHtcbiAgZmlyc3ROYW1lPzogc3RyaW5nO1xuICBsYXN0TmFtZT86IHN0cmluZztcbiAgcGhvbmVOdW1iZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBjbGFzcyBVc2VyU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgdXNlclJlcG9zaXRvcnk6IFVzZXJSZXBvc2l0b3J5LFxuICAgIHByaXZhdGUgbm90aWZpY2F0aW9uU2VydmljZT86IGFueVxuICApIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIG5ldyB1c2VyXG4gICAqIFRERDogSW1wbGVtZW50cyByZWdpc3RyYXRpb24gdGVzdHNcbiAgICovXG4gIGFzeW5jIHJlZ2lzdGVyKGRhdGE6IFJlZ2lzdGVyRHRvKTogUHJvbWlzZTx7IHVzZXI6IFVzZXIgfT4ge1xuICAgIC8vIFZhbGlkYXRlIHBhc3N3b3JkIHN0cmVuZ3RoXG4gICAgY29uc3QgcGFzc3dvcmRWYWxpZGF0aW9uID0gdmFsaWRhdGVQYXNzd29yZFN0cmVuZ3RoKGRhdGEucGFzc3dvcmQpO1xuICAgIGlmICghcGFzc3dvcmRWYWxpZGF0aW9uLnZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEVycm9yKHBhc3N3b3JkVmFsaWRhdGlvbi5lcnJvcnMuam9pbignLCAnKSk7XG4gICAgfVxuXG4gICAgLy8gSGFzaCBwYXNzd29yZFxuICAgIGNvbnN0IGhhc2hlZFBhc3N3b3JkID0gYXdhaXQgaGFzaFBhc3N3b3JkKGRhdGEucGFzc3dvcmQpO1xuXG4gICAgLy8gR2VuZXJhdGUgZW1haWwgdmVyaWZpY2F0aW9uIHRva2VuXG4gICAgY29uc3QgZW1haWxWZXJpZmljYXRpb25Ub2tlbiA9IHRoaXMuZ2VuZXJhdGVUb2tlbigpO1xuXG4gICAgLy8gQ3JlYXRlIHVzZXJcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS5jcmVhdGVVc2VyKHtcbiAgICAgIGVtYWlsOiBkYXRhLmVtYWlsLFxuICAgICAgcGFzc3dvcmQ6IGhhc2hlZFBhc3N3b3JkLFxuICAgICAgZmlyc3ROYW1lOiBkYXRhLmZpcnN0TmFtZSxcbiAgICAgIGxhc3ROYW1lOiBkYXRhLmxhc3ROYW1lLFxuICAgICAgcGhvbmVOdW1iZXI6IGRhdGEucGhvbmVOdW1iZXIsXG4gICAgICBlbWFpbFZlcmlmaWNhdGlvblRva2VuLFxuICAgIH0pO1xuXG4gICAgLy8gU2VuZCB2ZXJpZmljYXRpb24gZW1haWwgaWYgbm90aWZpY2F0aW9uIHNlcnZpY2UgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHRoaXMubm90aWZpY2F0aW9uU2VydmljZSkge1xuICAgICAgYXdhaXQgdGhpcy5ub3RpZmljYXRpb25TZXJ2aWNlLnNlbmRWZXJpZmljYXRpb25FbWFpbCh1c2VyLmVtYWlsLCBlbWFpbFZlcmlmaWNhdGlvblRva2VuKTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB1c2VyIH07XG4gIH1cblxuICAvKipcbiAgICogTG9naW4gdXNlclxuICAgKiBUREQ6IEltcGxlbWVudHMgbG9naW4gdGVzdHNcbiAgICovXG4gIGFzeW5jIGxvZ2luKGVtYWlsT3JDcmVkZW50aWFsczogc3RyaW5nIHwgTG9naW5EdG8sIHBhc3N3b3JkPzogc3RyaW5nKTogUHJvbWlzZTxMb2dpblJlc3BvbnNlPiB7XG4gICAgLy8gSGFuZGxlIGJvdGggc2lnbmF0dXJlczogbG9naW4oZW1haWwsIHBhc3N3b3JkKSBhbmQgbG9naW4oe2VtYWlsLCBwYXNzd29yZH0pXG4gICAgbGV0IGNyZWRlbnRpYWxzOiBMb2dpbkR0bztcbiAgICBpZiAodHlwZW9mIGVtYWlsT3JDcmVkZW50aWFscyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGNyZWRlbnRpYWxzID0geyBlbWFpbDogZW1haWxPckNyZWRlbnRpYWxzLCBwYXNzd29yZDogcGFzc3dvcmQhIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNyZWRlbnRpYWxzID0gZW1haWxPckNyZWRlbnRpYWxzO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdXNlciBieSBlbWFpbFxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LmZpbmRCeUVtYWlsKGNyZWRlbnRpYWxzLmVtYWlsKTtcblxuICAgIGlmICghdXNlcikge1xuICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEVycm9yKCdJbnZhbGlkIGNyZWRlbnRpYWxzJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYWNjb3VudCBpcyBsb2NrZWRcbiAgICBpZiAodXNlci5sb2NrZWRVbnRpbCAmJiB1c2VyLmxvY2tlZFVudGlsID4gbmV3IERhdGUoKSkge1xuICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEVycm9yKCdBY2NvdW50IGlzIGxvY2tlZC4gUGxlYXNlIHRyeSBhZ2FpbiBsYXRlci4nKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBpZiBhY2NvdW50IGlzIHN1c3BlbmRlZFxuICAgIGlmICh1c2VyLnN0YXR1cyA9PT0gVXNlclN0YXR1cy5TVVNQRU5ERUQpIHtcbiAgICAgIHRocm93IG5ldyBVbmF1dGhvcml6ZWRFcnJvcignQWNjb3VudCBpcyBzdXNwZW5kZWQnKTtcbiAgICB9XG5cbiAgICAvLyBWZXJpZnkgcGFzc3dvcmRcbiAgICBjb25zdCBpc1Bhc3N3b3JkVmFsaWQgPSBhd2FpdCBjb21wYXJlUGFzc3dvcmQoY3JlZGVudGlhbHMucGFzc3dvcmQsIHVzZXIucGFzc3dvcmQpO1xuXG4gICAgaWYgKCFpc1Bhc3N3b3JkVmFsaWQpIHtcbiAgICAgIC8vIEluY3JlbWVudCBsb2dpbiBhdHRlbXB0c1xuICAgICAgYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS5pbmNyZW1lbnRMb2dpbkF0dGVtcHRzKHVzZXIuaWQpO1xuICAgICAgdGhyb3cgbmV3IFVuYXV0aG9yaXplZEVycm9yKCdJbnZhbGlkIGNyZWRlbnRpYWxzJyk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgZW1haWwgaXMgdmVyaWZpZWRcbiAgICBpZiAoIXVzZXIuZW1haWxWZXJpZmllZEF0KSB7XG4gICAgICB0aHJvdyBuZXcgVW5hdXRob3JpemVkRXJyb3IoJ1BsZWFzZSB2ZXJpZnkgeW91ciBlbWFpbCBiZWZvcmUgbG9nZ2luZyBpbicpO1xuICAgIH1cblxuICAgIC8vIFJlc2V0IGxvZ2luIGF0dGVtcHRzIG9uIHN1Y2Nlc3NmdWwgbG9naW5cbiAgICBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LnJlc2V0TG9naW5BdHRlbXB0cyh1c2VyLmlkKTtcblxuICAgIC8vIFVwZGF0ZSBsYXN0IGxvZ2luIHRpbWVzdGFtcFxuICAgIGF3YWl0IHRoaXMudXNlclJlcG9zaXRvcnkudXBkYXRlTGFzdExvZ2luKHVzZXIuaWQpO1xuXG4gICAgLy8gR2VuZXJhdGUgdG9rZW5zXG4gICAgY29uc3QgYWNjZXNzVG9rZW4gPSBnZW5lcmF0ZUFjY2Vzc1Rva2VuKHtcbiAgICAgIHVzZXJJZDogdXNlci5pZCxcbiAgICAgIGVtYWlsOiB1c2VyLmVtYWlsLFxuICAgICAgcm9sZTogdXNlci5yb2xlLFxuICAgIH0pO1xuXG4gICAgY29uc3QgcmVmcmVzaFRva2VuID0gZ2VuZXJhdGVSZWZyZXNoVG9rZW4oe1xuICAgICAgdXNlcklkOiB1c2VyLmlkLFxuICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICByb2xlOiB1c2VyLnJvbGUsXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdXNlcixcbiAgICAgIGFjY2Vzc1Rva2VuLFxuICAgICAgcmVmcmVzaFRva2VuLFxuICAgICAgdG9rZW46IGFjY2Vzc1Rva2VuLCAvLyBBbGlhcyBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmVyaWZ5IGVtYWlsIHdpdGggdG9rZW5cbiAgICogVEREOiBJbXBsZW1lbnRzIHZlcmlmeUVtYWlsIHRlc3RzXG4gICAqL1xuICBhc3luYyB2ZXJpZnlFbWFpbCh0b2tlbjogc3RyaW5nKTogUHJvbWlzZTxVc2VyPiB7XG4gICAgcmV0dXJuIHRoaXMudXNlclJlcG9zaXRvcnkudmVyaWZ5RW1haWwodG9rZW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2VuZCB2ZXJpZmljYXRpb24gZW1haWxcbiAgICovXG4gIGFzeW5jIHJlc2VuZFZlcmlmaWNhdGlvbkVtYWlsKGVtYWlsOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS5maW5kQnlFbWFpbChlbWFpbCk7XG5cbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXJyb3IoJ1VzZXIgbm90IGZvdW5kJyk7XG4gICAgfVxuXG4gICAgaWYgKHVzZXIuZW1haWxWZXJpZmllZEF0KSB7XG4gICAgICB0aHJvdyBuZXcgQmFkUmVxdWVzdEVycm9yKCdFbWFpbCBhbHJlYWR5IHZlcmlmaWVkJyk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgbmV3IHZlcmlmaWNhdGlvbiB0b2tlblxuICAgIGNvbnN0IGVtYWlsVmVyaWZpY2F0aW9uVG9rZW4gPSB0aGlzLmdlbmVyYXRlVG9rZW4oKTtcbiAgICBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LnVwZGF0ZSh1c2VyLmlkLCB7IGVtYWlsVmVyaWZpY2F0aW9uVG9rZW4gfSk7XG5cbiAgICAvLyBTZW5kIHZlcmlmaWNhdGlvbiBlbWFpbCBpZiBub3RpZmljYXRpb24gc2VydmljZSBpcyBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5ub3RpZmljYXRpb25TZXJ2aWNlKSB7XG4gICAgICBhd2FpdCB0aGlzLm5vdGlmaWNhdGlvblNlcnZpY2Uuc2VuZFZlcmlmaWNhdGlvbkVtYWlsKHVzZXIuZW1haWwsIGVtYWlsVmVyaWZpY2F0aW9uVG9rZW4pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IGVtYWlsIGNoYW5nZVxuICAgKi9cbiAgYXN5bmMgcmVxdWVzdEVtYWlsQ2hhbmdlKHVzZXJJZDogc3RyaW5nLCBuZXdFbWFpbDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcbiAgICAvLyBWZXJpZnkgdXNlciBleGlzdHNcbiAgICBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LmZpbmRCeUlkKHVzZXJJZCk7XG5cbiAgICAvLyBDaGVjayBpZiBuZXcgZW1haWwgaXMgYWxyZWFkeSB0YWtlblxuICAgIGNvbnN0IGV4aXN0aW5nVXNlciA9IGF3YWl0IHRoaXMudXNlclJlcG9zaXRvcnkuZmluZEJ5RW1haWwobmV3RW1haWwpO1xuICAgIGlmIChleGlzdGluZ1VzZXIgJiYgZXhpc3RpbmdVc2VyLmlkICE9PSB1c2VySWQpIHtcbiAgICAgIHRocm93IG5ldyBCYWRSZXF1ZXN0RXJyb3IoJ0VtYWlsIGFscmVhZHkgaW4gdXNlJyk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgdmVyaWZpY2F0aW9uIHRva2VuIGZvciBuZXcgZW1haWxcbiAgICBjb25zdCB2ZXJpZmljYXRpb25Ub2tlbiA9IHRoaXMuZ2VuZXJhdGVUb2tlbigpO1xuXG4gICAgLy8gU3RvcmUgdGhlIHBlbmRpbmcgZW1haWwgY2hhbmdlIChpbiBwcm9kdWN0aW9uLCB3b3VsZCBzdG9yZSBpbiBkYXRhYmFzZSlcbiAgICAvLyBGb3Igbm93LCB3ZSdsbCB1c2UgdGhlIGVtYWlsVmVyaWZpY2F0aW9uVG9rZW4gZmllbGRcbiAgICBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LnVwZGF0ZSh1c2VySWQsIHtcbiAgICAgIGVtYWlsVmVyaWZpY2F0aW9uVG9rZW46IHZlcmlmaWNhdGlvblRva2VuLFxuICAgIH0pO1xuXG4gICAgLy8gU2VuZCB2ZXJpZmljYXRpb24gZW1haWwgdG8gbmV3IGFkZHJlc3MgaWYgbm90aWZpY2F0aW9uIHNlcnZpY2UgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHRoaXMubm90aWZpY2F0aW9uU2VydmljZSkge1xuICAgICAgYXdhaXQgdGhpcy5ub3RpZmljYXRpb25TZXJ2aWNlLnNlbmRWZXJpZmljYXRpb25FbWFpbChuZXdFbWFpbCwgdmVyaWZpY2F0aW9uVG9rZW4pO1xuICAgIH1cblxuICAgIHJldHVybiB2ZXJpZmljYXRpb25Ub2tlbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBWZXJpZnkgbmV3IGVtYWlsIHdpdGggdG9rZW5cbiAgICovXG4gIGFzeW5jIHZlcmlmeU5ld0VtYWlsKHZlcmlmaWNhdGlvblRva2VuOiBzdHJpbmcpOiBQcm9taXNlPFVzZXI+IHtcbiAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHdlIHdvdWxkIGxvb2sgdXAgdGhlIHBlbmRpbmcgZW1haWwgY2hhbmdlIGJ5IHRva2VuXG4gICAgLy8gRm9yIG5vdywgd2UnbGwganVzdCB2ZXJpZnkgdGhlIHRva2VuIGV4aXN0c1xuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LnZlcmlmeUVtYWlsKHZlcmlmaWNhdGlvblRva2VuKTtcbiAgICByZXR1cm4gdXNlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHBhc3N3b3JkIHJlc2V0XG4gICAqIFRERDogSW1wbGVtZW50cyByZXF1ZXN0UGFzc3dvcmRSZXNldCB0ZXN0c1xuICAgKi9cbiAgYXN5bmMgcmVxdWVzdFBhc3N3b3JkUmVzZXQoZW1haWw6IHN0cmluZyk6IFByb21pc2U8VXNlciB8IG51bGw+IHtcbiAgICBjb25zdCB1c2VyID0gYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS5maW5kQnlFbWFpbChlbWFpbCk7XG5cbiAgICAvLyBEb24ndCByZXZlYWwgaWYgZW1haWwgZXhpc3RzIChzZWN1cml0eSBiZXN0IHByYWN0aWNlKVxuICAgIGlmICghdXNlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzZXRUb2tlbiA9IHRoaXMuZ2VuZXJhdGVUb2tlbigpO1xuICAgIGF3YWl0IHRoaXMudXNlclJlcG9zaXRvcnkuc2V0UGFzc3dvcmRSZXNldFRva2VuKHVzZXIuaWQsIHJlc2V0VG9rZW4pO1xuXG4gICAgcmV0dXJuIHVzZXI7XG4gIH1cblxuICAvKipcbiAgICogUmVzZXQgcGFzc3dvcmQgd2l0aCB0b2tlblxuICAgKiBUREQ6IEltcGxlbWVudHMgcmVzZXRQYXNzd29yZCB0ZXN0c1xuICAgKi9cbiAgYXN5bmMgcmVzZXRQYXNzd29yZCh0b2tlbjogc3RyaW5nLCBuZXdQYXNzd29yZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyPiB7XG4gICAgLy8gVmFsaWRhdGUgbmV3IHBhc3N3b3JkXG4gICAgY29uc3QgcGFzc3dvcmRWYWxpZGF0aW9uID0gdmFsaWRhdGVQYXNzd29yZFN0cmVuZ3RoKG5ld1Bhc3N3b3JkKTtcbiAgICBpZiAoIXBhc3N3b3JkVmFsaWRhdGlvbi52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFcnJvcihwYXNzd29yZFZhbGlkYXRpb24uZXJyb3JzLmpvaW4oJywgJykpO1xuICAgIH1cblxuICAgIC8vIEhhc2ggbmV3IHBhc3N3b3JkXG4gICAgY29uc3QgaGFzaGVkUGFzc3dvcmQgPSBhd2FpdCBoYXNoUGFzc3dvcmQobmV3UGFzc3dvcmQpO1xuXG4gICAgLy8gUmVzZXQgcGFzc3dvcmRcbiAgICByZXR1cm4gdGhpcy51c2VyUmVwb3NpdG9yeS5yZXNldFBhc3N3b3JkKHRva2VuLCBoYXNoZWRQYXNzd29yZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXIgYnkgSURcbiAgICogVEREOiBJbXBsZW1lbnRzIGdldFVzZXJCeUlkIHRlc3RzXG4gICAqL1xuICBhc3luYyBnZXRVc2VyQnlJZCh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8VXNlcj4ge1xuICAgIHJldHVybiB0aGlzLnVzZXJSZXBvc2l0b3J5LmZpbmRCeUlkKHVzZXJJZCk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHVzZXIgcHJvZmlsZVxuICAgKiBUREQ6IEltcGxlbWVudHMgdXBkYXRlUHJvZmlsZSB0ZXN0c1xuICAgKi9cbiAgYXN5bmMgdXBkYXRlUHJvZmlsZSh1c2VySWQ6IHN0cmluZywgZGF0YTogVXBkYXRlUHJvZmlsZUR0byk6IFByb21pc2U8VXNlcj4ge1xuICAgIC8vIEZpbHRlciBvdXQgc2Vuc2l0aXZlIGZpZWxkcyB0aGF0IHNob3VsZCBub3QgYmUgdXBkYXRlZCBkaXJlY3RseVxuICAgIGNvbnN0IGFsbG93ZWRGaWVsZHM6IFVwZGF0ZVByb2ZpbGVEdG8gPSB7XG4gICAgICBmaXJzdE5hbWU6IGRhdGEuZmlyc3ROYW1lLFxuICAgICAgbGFzdE5hbWU6IGRhdGEubGFzdE5hbWUsXG4gICAgICBwaG9uZU51bWJlcjogZGF0YS5waG9uZU51bWJlcixcbiAgICB9O1xuXG4gICAgLy8gUmVtb3ZlIHVuZGVmaW5lZCB2YWx1ZXNcbiAgICBjb25zdCB1cGRhdGVEYXRhID0gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgICAgT2JqZWN0LmVudHJpZXMoYWxsb3dlZEZpZWxkcykuZmlsdGVyKChbXywgdl0pID0+IHYgIT09IHVuZGVmaW5lZClcbiAgICApO1xuXG4gICAgcmV0dXJuIHRoaXMudXNlclJlcG9zaXRvcnkudXBkYXRlKHVzZXJJZCwgdXBkYXRlRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlIHBhc3N3b3JkIChyZXF1aXJlcyBvbGQgcGFzc3dvcmQpXG4gICAqIFRERDogSW1wbGVtZW50cyBjaGFuZ2VQYXNzd29yZCB0ZXN0c1xuICAgKi9cbiAgYXN5bmMgY2hhbmdlUGFzc3dvcmQoXG4gICAgdXNlcklkOiBzdHJpbmcsXG4gICAgb2xkUGFzc3dvcmQ6IHN0cmluZyxcbiAgICBuZXdQYXNzd29yZDogc3RyaW5nXG4gICk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIEdldCB1c2VyXG4gICAgY29uc3QgdXNlciA9IGF3YWl0IHRoaXMudXNlclJlcG9zaXRvcnkuZmluZEJ5SWQodXNlcklkKTtcblxuICAgIC8vIFZlcmlmeSBvbGQgcGFzc3dvcmRcbiAgICBjb25zdCBpc09sZFBhc3N3b3JkVmFsaWQgPSBhd2FpdCBjb21wYXJlUGFzc3dvcmQob2xkUGFzc3dvcmQsIHVzZXIucGFzc3dvcmQpO1xuICAgIGlmICghaXNPbGRQYXNzd29yZFZhbGlkKSB7XG4gICAgICB0aHJvdyBuZXcgVW5hdXRob3JpemVkRXJyb3IoJ0N1cnJlbnQgcGFzc3dvcmQgaXMgaW5jb3JyZWN0Jyk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgbmV3IHBhc3N3b3JkXG4gICAgY29uc3QgcGFzc3dvcmRWYWxpZGF0aW9uID0gdmFsaWRhdGVQYXNzd29yZFN0cmVuZ3RoKG5ld1Bhc3N3b3JkKTtcbiAgICBpZiAoIXBhc3N3b3JkVmFsaWRhdGlvbi52YWxpZCkge1xuICAgICAgdGhyb3cgbmV3IEJhZFJlcXVlc3RFcnJvcihwYXNzd29yZFZhbGlkYXRpb24uZXJyb3JzLmpvaW4oJywgJykpO1xuICAgIH1cblxuICAgIC8vIEhhc2ggbmV3IHBhc3N3b3JkXG4gICAgY29uc3QgaGFzaGVkUGFzc3dvcmQgPSBhd2FpdCBoYXNoUGFzc3dvcmQobmV3UGFzc3dvcmQpO1xuXG4gICAgLy8gVXBkYXRlIHBhc3N3b3JkXG4gICAgYXdhaXQgdGhpcy51c2VyUmVwb3NpdG9yeS51cGRhdGUodXNlcklkLCB7IHBhc3N3b3JkOiBoYXNoZWRQYXNzd29yZCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoIGFjY2VzcyB0b2tlblxuICAgKiBUREQ6IEltcGxlbWVudHMgcmVmcmVzaFRva2VuIHRlc3RzXG4gICAqL1xuICBhc3luYyByZWZyZXNoVG9rZW4ocmVmcmVzaFRva2VuOiBzdHJpbmcpOiBQcm9taXNlPHsgYWNjZXNzVG9rZW46IHN0cmluZyB9PiB7XG4gICAgLy8gVmVyaWZ5IHJlZnJlc2ggdG9rZW5cbiAgICBjb25zdCBwYXlsb2FkID0gdmVyaWZ5UmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbik7XG5cbiAgICAvLyBFbnN1cmUgdXNlciBzdGlsbCBleGlzdHMgYW5kIGlzIGFjdGl2ZVxuICAgIGNvbnN0IHVzZXIgPSBhd2FpdCB0aGlzLnVzZXJSZXBvc2l0b3J5LmZpbmRCeUlkKHBheWxvYWQudXNlcklkKTtcblxuICAgIGlmICh1c2VyLnN0YXR1cyAhPT0gVXNlclN0YXR1cy5BQ1RJVkUpIHtcbiAgICAgIHRocm93IG5ldyBVbmF1dGhvcml6ZWRFcnJvcignQWNjb3VudCBpcyBub3QgYWN0aXZlJyk7XG4gICAgfVxuXG4gICAgLy8gR2VuZXJhdGUgbmV3IGFjY2VzcyB0b2tlblxuICAgIGNvbnN0IGFjY2Vzc1Rva2VuID0gZ2VuZXJhdGVBY2Nlc3NUb2tlbih7XG4gICAgICB1c2VySWQ6IHVzZXIuaWQsXG4gICAgICBlbWFpbDogdXNlci5lbWFpbCxcbiAgICAgIHJvbGU6IHVzZXIucm9sZSxcbiAgICB9KTtcblxuICAgIHJldHVybiB7IGFjY2Vzc1Rva2VuIH07XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgcmFuZG9tIHRva2VuXG4gICAqL1xuICBwcml2YXRlIGdlbmVyYXRlVG9rZW4oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gcmFuZG9tQnl0ZXMoMzIpLnRvU3RyaW5nKCdoZXgnKTtcbiAgfVxufVxuIl0sInZlcnNpb24iOjN9