{"file":"C:\\Adaptive_Testing\\src\\services\\user-management\\services\\user.service.ts","mappings":";AAAA;;;;;GAKG;;;AAGH,yDAA2D;AAC3D,yCAGsB;AACtB,8DAImC;AACnC,oDAAqG;AACrG,mCAAqC;AA4BrC,MAAa,WAAW;IAEZ;IACA;IAFV,YACU,cAA8B,EAC9B,mBAAyB;QADzB,mBAAc,GAAd,cAAc,CAAgB;QAC9B,wBAAmB,GAAnB,mBAAmB,CAAM;IAChC,CAAC;IAEJ;;;OAGG;IACH,KAAK,CAAC,QAAQ,CAAC,IAAiB;QAC9B,6BAA6B;QAC7B,MAAM,kBAAkB,GAAG,IAAA,yCAAwB,EAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACnE,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;YAC9B,MAAM,IAAI,wBAAe,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAClE,CAAC;QAED,gBAAgB;QAChB,MAAM,cAAc,GAAG,MAAM,IAAA,6BAAY,EAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QAEzD,oCAAoC;QACpC,MAAM,sBAAsB,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QAEpD,cAAc;QACd,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,UAAU,CAAC;YAChD,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,QAAQ,EAAE,cAAc;YACxB,SAAS,EAAE,IAAI,CAAC,SAAS;YACzB,QAAQ,EAAE,IAAI,CAAC,QAAQ;YACvB,WAAW,EAAE,IAAI,CAAC,WAAW;YAC7B,sBAAsB;SACvB,CAAC,CAAC;QAEH,+DAA+D;QAC/D,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC7B,MAAM,IAAI,CAAC,mBAAmB,CAAC,qBAAqB,CAAC,IAAI,CAAC,KAAK,EAAE,sBAAsB,CAAC,CAAC;QAC3F,CAAC;QAED,OAAO,EAAE,IAAI,EAAE,CAAC;IAClB,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,KAAK,CAAC,kBAAqC,EAAE,QAAiB;QAClE,8EAA8E;QAC9E,IAAI,WAAqB,CAAC;QAC1B,IAAI,OAAO,kBAAkB,KAAK,QAAQ,EAAE,CAAC;YAC3C,WAAW,GAAG,EAAE,KAAK,EAAE,kBAAkB,EAAE,QAAQ,EAAE,QAAS,EAAE,CAAC;QACnE,CAAC;aAAM,CAAC;YACN,WAAW,GAAG,kBAAkB,CAAC;QACnC,CAAC;QAED,qBAAqB;QACrB,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAEtE,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,MAAM,IAAI,0BAAiB,CAAC,qBAAqB,CAAC,CAAC;QACrD,CAAC;QAED,6BAA6B;QAC7B,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW,GAAG,IAAI,IAAI,EAAE,EAAE,CAAC;YACtD,MAAM,IAAI,0BAAiB,CAAC,4CAA4C,CAAC,CAAC;QAC5E,CAAC;QAED,gCAAgC;QAChC,IAAI,IAAI,CAAC,MAAM,KAAK,wBAAU,CAAC,SAAS,EAAE,CAAC;YACzC,MAAM,IAAI,0BAAiB,CAAC,sBAAsB,CAAC,CAAC;QACtD,CAAC;QAED,kBAAkB;QAClB,MAAM,eAAe,GAAG,MAAM,IAAA,gCAAe,EAAC,WAAW,CAAC,QAAQ,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAEnF,IAAI,CAAC,eAAe,EAAE,CAAC;YACrB,2BAA2B;YAC3B,MAAM,IAAI,CAAC,cAAc,CAAC,sBAAsB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;YAC1D,MAAM,IAAI,0BAAiB,CAAC,qBAAqB,CAAC,CAAC;QACrD,CAAC;QAED,6BAA6B;QAC7B,IAAI,CAAC,IAAI,CAAC,eAAe,EAAE,CAAC;YAC1B,MAAM,IAAI,0BAAiB,CAAC,4CAA4C,CAAC,CAAC;QAC5E,CAAC;QAED,2CAA2C;QAC3C,MAAM,IAAI,CAAC,cAAc,CAAC,kBAAkB,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAEtD,8BAA8B;QAC9B,MAAM,IAAI,CAAC,cAAc,CAAC,eAAe,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;QAEnD,kBAAkB;QAClB,MAAM,WAAW,GAAG,IAAA,+BAAmB,EAAC;YACtC,MAAM,EAAE,IAAI,CAAC,EAAE;YACf,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,IAAI,EAAE,IAAI,CAAC,IAAI;SAChB,CAAC,CAAC;QAEH,MAAM,YAAY,GAAG,IAAA,gCAAoB,EAAC;YACxC,MAAM,EAAE,IAAI,CAAC,EAAE;YACf,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,IAAI,EAAE,IAAI,CAAC,IAAI;SAChB,CAAC,CAAC;QAEH,OAAO;YACL,IAAI;YACJ,WAAW;YACX,YAAY;YACZ,KAAK,EAAE,WAAW,EAAE,mCAAmC;SACxD,CAAC;IACJ,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,WAAW,CAAC,KAAa;QAC7B,OAAO,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;IAChD,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,uBAAuB,CAAC,KAAa;QACzC,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAE1D,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,MAAM,IAAI,wBAAe,CAAC,gBAAgB,CAAC,CAAC;QAC9C,CAAC;QAED,IAAI,IAAI,CAAC,eAAe,EAAE,CAAC;YACzB,MAAM,IAAI,wBAAe,CAAC,wBAAwB,CAAC,CAAC;QACtD,CAAC;QAED,kCAAkC;QAClC,MAAM,sBAAsB,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QACpD,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI,CAAC,EAAE,EAAE,EAAE,sBAAsB,EAAE,CAAC,CAAC;QAEtE,+DAA+D;QAC/D,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC7B,MAAM,IAAI,CAAC,mBAAmB,CAAC,qBAAqB,CAAC,IAAI,CAAC,KAAK,EAAE,sBAAsB,CAAC,CAAC;QAC3F,CAAC;IACH,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,kBAAkB,CAAC,MAAc,EAAE,QAAgB;QACvD,qBAAqB;QACrB,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAE3C,sCAAsC;QACtC,MAAM,YAAY,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QACrE,IAAI,YAAY,IAAI,YAAY,CAAC,EAAE,KAAK,MAAM,EAAE,CAAC;YAC/C,MAAM,IAAI,wBAAe,CAAC,sBAAsB,CAAC,CAAC;QACpD,CAAC;QAED,4CAA4C;QAC5C,MAAM,iBAAiB,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QAE/C,0EAA0E;QAC1E,sDAAsD;QACtD,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,MAAM,EAAE;YACvC,sBAAsB,EAAE,iBAAiB;SAC1C,CAAC,CAAC;QAEH,8EAA8E;QAC9E,IAAI,IAAI,CAAC,mBAAmB,EAAE,CAAC;YAC7B,MAAM,IAAI,CAAC,mBAAmB,CAAC,qBAAqB,CAAC,QAAQ,EAAE,iBAAiB,CAAC,CAAC;QACpF,CAAC;QAED,OAAO,iBAAiB,CAAC;IAC3B,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,cAAc,CAAC,iBAAyB;QAC5C,+EAA+E;QAC/E,8CAA8C;QAC9C,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,iBAAiB,CAAC,CAAC;QACtE,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,oBAAoB,CAAC,KAAa;QACtC,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;QAE1D,wDAAwD;QACxD,IAAI,CAAC,IAAI,EAAE,CAAC;YACV,OAAO,IAAI,CAAC;QACd,CAAC;QAED,MAAM,UAAU,GAAG,IAAI,CAAC,aAAa,EAAE,CAAC;QACxC,MAAM,IAAI,CAAC,cAAc,CAAC,qBAAqB,CAAC,IAAI,CAAC,EAAE,EAAE,UAAU,CAAC,CAAC;QAErE,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,aAAa,CAAC,KAAa,EAAE,WAAmB;QACpD,wBAAwB;QACxB,MAAM,kBAAkB,GAAG,IAAA,yCAAwB,EAAC,WAAW,CAAC,CAAC;QACjE,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;YAC9B,MAAM,IAAI,wBAAe,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAClE,CAAC;QAED,oBAAoB;QACpB,MAAM,cAAc,GAAG,MAAM,IAAA,6BAAY,EAAC,WAAW,CAAC,CAAC;QAEvD,iBAAiB;QACjB,OAAO,IAAI,CAAC,cAAc,CAAC,aAAa,CAAC,KAAK,EAAE,cAAc,CAAC,CAAC;IAClE,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,WAAW,CAAC,MAAc;QAC9B,OAAO,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;IAC9C,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,aAAa,CAAC,MAAc,EAAE,IAAsB;QACxD,kEAAkE;QAClE,MAAM,aAAa,GAAqB;YACtC,SAAS,EAAE,IAAI,CAAC,SAAS;YACzB,QAAQ,EAAE,IAAI,CAAC,QAAQ;YACvB,WAAW,EAAE,IAAI,CAAC,WAAW;SAC9B,CAAC;QAEF,0BAA0B;QAC1B,MAAM,UAAU,GAAG,MAAM,CAAC,WAAW,CACnC,MAAM,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,KAAK,SAAS,CAAC,CAClE,CAAC;QAEF,OAAO,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;IACxD,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,cAAc,CAClB,MAAc,EACd,WAAmB,EACnB,WAAmB;QAEnB,WAAW;QACX,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QAExD,sBAAsB;QACtB,MAAM,kBAAkB,GAAG,MAAM,IAAA,gCAAe,EAAC,WAAW,EAAE,IAAI,CAAC,QAAQ,CAAC,CAAC;QAC7E,IAAI,CAAC,kBAAkB,EAAE,CAAC;YACxB,MAAM,IAAI,0BAAiB,CAAC,+BAA+B,CAAC,CAAC;QAC/D,CAAC;QAED,wBAAwB;QACxB,MAAM,kBAAkB,GAAG,IAAA,yCAAwB,EAAC,WAAW,CAAC,CAAC;QACjE,IAAI,CAAC,kBAAkB,CAAC,KAAK,EAAE,CAAC;YAC9B,MAAM,IAAI,wBAAe,CAAC,kBAAkB,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC;QAClE,CAAC;QAED,oBAAoB;QACpB,MAAM,cAAc,GAAG,MAAM,IAAA,6BAAY,EAAC,WAAW,CAAC,CAAC;QAEvD,kBAAkB;QAClB,MAAM,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,MAAM,EAAE,EAAE,QAAQ,EAAE,cAAc,EAAE,CAAC,CAAC;IACzE,CAAC;IAED;;;OAGG;IACH,KAAK,CAAC,YAAY,CAAC,YAAoB;QACrC,uBAAuB;QACvB,MAAM,OAAO,GAAG,IAAA,8BAAkB,EAAC,YAAY,CAAC,CAAC;QAEjD,yCAAyC;QACzC,MAAM,IAAI,GAAG,MAAM,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;QAEhE,IAAI,IAAI,CAAC,MAAM,KAAK,wBAAU,CAAC,MAAM,EAAE,CAAC;YACtC,MAAM,IAAI,0BAAiB,CAAC,uBAAuB,CAAC,CAAC;QACvD,CAAC;QAED,4BAA4B;QAC5B,MAAM,WAAW,GAAG,IAAA,+BAAmB,EAAC;YACtC,MAAM,EAAE,IAAI,CAAC,EAAE;YACf,KAAK,EAAE,IAAI,CAAC,KAAK;YACjB,IAAI,EAAE,IAAI,CAAC,IAAI;SAChB,CAAC,CAAC;QAEH,OAAO,EAAE,WAAW,EAAE,CAAC;IACzB,CAAC;IAED;;OAEG;IACK,aAAa;QACnB,OAAO,IAAA,oBAAW,EAAC,EAAE,CAAC,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;IACzC,CAAC;CACF;AAtTD,kCAsTC","names":[],"sources":["C:\\Adaptive_Testing\\src\\services\\user-management\\services\\user.service.ts"],"sourcesContent":["/**\n * TDD Implementation: User Service\n *\n * Business logic layer for user management\n * Implements all functionality to pass tests in user.service.spec.ts\n */\n\nimport { UserRepository } from '../repositories/user.repository';\nimport { User, UserStatus } from '../entities/user.entity';\nimport {\n  UnauthorizedError,\n  BadRequestError,\n} from '@libs/errors';\nimport {\n  hashPassword,\n  comparePassword,\n  validatePasswordStrength,\n} from '@libs/auth/password.utils';\nimport { generateAccessToken, generateRefreshToken, verifyRefreshToken } from '@libs/auth/jwt.utils';\nimport { randomBytes } from 'crypto';\n\nexport interface RegisterDto {\n  email: string;\n  password: string;\n  firstName: string;\n  lastName: string;\n  phoneNumber?: string;\n}\n\nexport interface LoginDto {\n  email: string;\n  password: string;\n}\n\nexport interface LoginResponse {\n  user: User;\n  accessToken: string;\n  refreshToken: string;\n  token: string; // Alias for accessToken\n}\n\nexport interface UpdateProfileDto {\n  firstName?: string;\n  lastName?: string;\n  phoneNumber?: string;\n}\n\nexport class UserService {\n  constructor(\n    private userRepository: UserRepository,\n    private notificationService?: any\n  ) {}\n\n  /**\n   * Register new user\n   * TDD: Implements registration tests\n   */\n  async register(data: RegisterDto): Promise<{ user: User }> {\n    // Validate password strength\n    const passwordValidation = validatePasswordStrength(data.password);\n    if (!passwordValidation.valid) {\n      throw new BadRequestError(passwordValidation.errors.join(', '));\n    }\n\n    // Hash password\n    const hashedPassword = await hashPassword(data.password);\n\n    // Generate email verification token\n    const emailVerificationToken = this.generateToken();\n\n    // Create user\n    const user = await this.userRepository.createUser({\n      email: data.email,\n      password: hashedPassword,\n      firstName: data.firstName,\n      lastName: data.lastName,\n      phoneNumber: data.phoneNumber,\n      emailVerificationToken,\n    });\n\n    // Send verification email if notification service is available\n    if (this.notificationService) {\n      await this.notificationService.sendVerificationEmail(user.email, emailVerificationToken);\n    }\n\n    return { user };\n  }\n\n  /**\n   * Login user\n   * TDD: Implements login tests\n   */\n  async login(emailOrCredentials: string | LoginDto, password?: string): Promise<LoginResponse> {\n    // Handle both signatures: login(email, password) and login({email, password})\n    let credentials: LoginDto;\n    if (typeof emailOrCredentials === 'string') {\n      credentials = { email: emailOrCredentials, password: password! };\n    } else {\n      credentials = emailOrCredentials;\n    }\n\n    // Find user by email\n    const user = await this.userRepository.findByEmail(credentials.email);\n\n    if (!user) {\n      throw new UnauthorizedError('Invalid credentials');\n    }\n\n    // Check if account is locked\n    if (user.lockedUntil && user.lockedUntil > new Date()) {\n      throw new UnauthorizedError('Account is locked. Please try again later.');\n    }\n\n    // Check if account is suspended\n    if (user.status === UserStatus.SUSPENDED) {\n      throw new UnauthorizedError('Account is suspended');\n    }\n\n    // Verify password\n    const isPasswordValid = await comparePassword(credentials.password, user.password);\n\n    if (!isPasswordValid) {\n      // Increment login attempts\n      await this.userRepository.incrementLoginAttempts(user.id);\n      throw new UnauthorizedError('Invalid credentials');\n    }\n\n    // Check if email is verified\n    if (!user.emailVerifiedAt) {\n      throw new UnauthorizedError('Please verify your email before logging in');\n    }\n\n    // Reset login attempts on successful login\n    await this.userRepository.resetLoginAttempts(user.id);\n\n    // Update last login timestamp\n    await this.userRepository.updateLastLogin(user.id);\n\n    // Generate tokens\n    const accessToken = generateAccessToken({\n      userId: user.id,\n      email: user.email,\n      role: user.role,\n    });\n\n    const refreshToken = generateRefreshToken({\n      userId: user.id,\n      email: user.email,\n      role: user.role,\n    });\n\n    return {\n      user,\n      accessToken,\n      refreshToken,\n      token: accessToken, // Alias for backward compatibility\n    };\n  }\n\n  /**\n   * Verify email with token\n   * TDD: Implements verifyEmail tests\n   */\n  async verifyEmail(token: string): Promise<User> {\n    return this.userRepository.verifyEmail(token);\n  }\n\n  /**\n   * Resend verification email\n   */\n  async resendVerificationEmail(email: string): Promise<void> {\n    const user = await this.userRepository.findByEmail(email);\n\n    if (!user) {\n      throw new BadRequestError('User not found');\n    }\n\n    if (user.emailVerifiedAt) {\n      throw new BadRequestError('Email already verified');\n    }\n\n    // Generate new verification token\n    const emailVerificationToken = this.generateToken();\n    await this.userRepository.update(user.id, { emailVerificationToken });\n\n    // Send verification email if notification service is available\n    if (this.notificationService) {\n      await this.notificationService.sendVerificationEmail(user.email, emailVerificationToken);\n    }\n  }\n\n  /**\n   * Request email change\n   */\n  async requestEmailChange(userId: string, newEmail: string): Promise<string> {\n    // Verify user exists\n    await this.userRepository.findById(userId);\n\n    // Check if new email is already taken\n    const existingUser = await this.userRepository.findByEmail(newEmail);\n    if (existingUser && existingUser.id !== userId) {\n      throw new BadRequestError('Email already in use');\n    }\n\n    // Generate verification token for new email\n    const verificationToken = this.generateToken();\n\n    // Store the pending email change (in production, would store in database)\n    // For now, we'll use the emailVerificationToken field\n    await this.userRepository.update(userId, {\n      emailVerificationToken: verificationToken,\n    });\n\n    // Send verification email to new address if notification service is available\n    if (this.notificationService) {\n      await this.notificationService.sendVerificationEmail(newEmail, verificationToken);\n    }\n\n    return verificationToken;\n  }\n\n  /**\n   * Verify new email with token\n   */\n  async verifyNewEmail(verificationToken: string): Promise<User> {\n    // In a real implementation, we would look up the pending email change by token\n    // For now, we'll just verify the token exists\n    const user = await this.userRepository.verifyEmail(verificationToken);\n    return user;\n  }\n\n  /**\n   * Request password reset\n   * TDD: Implements requestPasswordReset tests\n   */\n  async requestPasswordReset(email: string): Promise<User | null> {\n    const user = await this.userRepository.findByEmail(email);\n\n    // Don't reveal if email exists (security best practice)\n    if (!user) {\n      return null;\n    }\n\n    const resetToken = this.generateToken();\n    await this.userRepository.setPasswordResetToken(user.id, resetToken);\n\n    return user;\n  }\n\n  /**\n   * Reset password with token\n   * TDD: Implements resetPassword tests\n   */\n  async resetPassword(token: string, newPassword: string): Promise<User> {\n    // Validate new password\n    const passwordValidation = validatePasswordStrength(newPassword);\n    if (!passwordValidation.valid) {\n      throw new BadRequestError(passwordValidation.errors.join(', '));\n    }\n\n    // Hash new password\n    const hashedPassword = await hashPassword(newPassword);\n\n    // Reset password\n    return this.userRepository.resetPassword(token, hashedPassword);\n  }\n\n  /**\n   * Get user by ID\n   * TDD: Implements getUserById tests\n   */\n  async getUserById(userId: string): Promise<User> {\n    return this.userRepository.findById(userId);\n  }\n\n  /**\n   * Update user profile\n   * TDD: Implements updateProfile tests\n   */\n  async updateProfile(userId: string, data: UpdateProfileDto): Promise<User> {\n    // Filter out sensitive fields that should not be updated directly\n    const allowedFields: UpdateProfileDto = {\n      firstName: data.firstName,\n      lastName: data.lastName,\n      phoneNumber: data.phoneNumber,\n    };\n\n    // Remove undefined values\n    const updateData = Object.fromEntries(\n      Object.entries(allowedFields).filter(([_, v]) => v !== undefined)\n    );\n\n    return this.userRepository.update(userId, updateData);\n  }\n\n  /**\n   * Change password (requires old password)\n   * TDD: Implements changePassword tests\n   */\n  async changePassword(\n    userId: string,\n    oldPassword: string,\n    newPassword: string\n  ): Promise<void> {\n    // Get user\n    const user = await this.userRepository.findById(userId);\n\n    // Verify old password\n    const isOldPasswordValid = await comparePassword(oldPassword, user.password);\n    if (!isOldPasswordValid) {\n      throw new UnauthorizedError('Current password is incorrect');\n    }\n\n    // Validate new password\n    const passwordValidation = validatePasswordStrength(newPassword);\n    if (!passwordValidation.valid) {\n      throw new BadRequestError(passwordValidation.errors.join(', '));\n    }\n\n    // Hash new password\n    const hashedPassword = await hashPassword(newPassword);\n\n    // Update password\n    await this.userRepository.update(userId, { password: hashedPassword });\n  }\n\n  /**\n   * Refresh access token\n   * TDD: Implements refreshToken tests\n   */\n  async refreshToken(refreshToken: string): Promise<{ accessToken: string }> {\n    // Verify refresh token\n    const payload = verifyRefreshToken(refreshToken);\n\n    // Ensure user still exists and is active\n    const user = await this.userRepository.findById(payload.userId);\n\n    if (user.status !== UserStatus.ACTIVE) {\n      throw new UnauthorizedError('Account is not active');\n    }\n\n    // Generate new access token\n    const accessToken = generateAccessToken({\n      userId: user.id,\n      email: user.email,\n      role: user.role,\n    });\n\n    return { accessToken };\n  }\n\n  /**\n   * Generate random token\n   */\n  private generateToken(): string {\n    return randomBytes(32).toString('hex');\n  }\n}\n"],"version":3}