{"file":"C:\\Adaptive_Testing\\src\\services\\product-catalog\\services\\product.service.ts","mappings":"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","names":[],"sources":["C:\\Adaptive_Testing\\src\\services\\product-catalog\\services\\product.service.ts"],"sourcesContent":["/**\n * TDD Implementation: Product Service\n *\n * Business logic layer for product management\n * Implements all functionality to pass tests in product.service.spec.ts\n */\n\nimport { ProductRepository, SearchProductsOptions, SearchProductsResult } from '../repositories/product.repository';\nimport { Product, ProductStatus } from '../entities/product.entity';\nimport { BadRequestError } from '@libs/errors';\n\nexport interface CreateProductDto {\n  name: string;\n  description: string;\n  sku: string;\n  price: number;\n  compareAtPrice?: number;\n  inventory: number;\n  categoryId?: string;\n  images?: string[];\n  metadata?: Record<string, unknown>;\n}\n\nexport interface UpdateProductDto {\n  name?: string;\n  description?: string;\n  price?: number;\n  compareAtPrice?: number;\n  categoryId?: string;\n  images?: string[];\n  metadata?: Record<string, unknown>;\n}\n\nexport class ProductService {\n  constructor(private productRepository: ProductRepository) {}\n\n  /**\n   * Create new product with validation\n   */\n  async createProduct(data: CreateProductDto): Promise<Product> {\n    // Validate price\n    if (data.price <= 0) {\n      throw new BadRequestError('Price must be positive');\n    }\n\n    // Validate inventory\n    if (data.inventory < 0) {\n      throw new BadRequestError('Inventory cannot be negative');\n    }\n\n    // Validate compareAtPrice if provided\n    if (data.compareAtPrice !== undefined) {\n      if (data.compareAtPrice <= data.price) {\n        throw new BadRequestError('Compare at price must be higher than price');\n      }\n    }\n\n    return this.productRepository.createProduct(data);\n  }\n\n  /**\n   * Get product by ID\n   */\n  async getProductById(productId: string): Promise<Product> {\n    return this.productRepository.findById(productId);\n  }\n\n  /**\n   * Update product\n   */\n  async updateProduct(productId: string, data: UpdateProductDto): Promise<Product> {\n    // Validate price if being updated\n    if (data.price !== undefined && data.price <= 0) {\n      throw new BadRequestError('Price must be positive');\n    }\n\n    // Validate compareAtPrice if being updated\n    if (data.compareAtPrice !== undefined && data.price !== undefined) {\n      if (data.compareAtPrice <= data.price) {\n        throw new BadRequestError('Compare at price must be higher than price');\n      }\n    }\n\n    return this.productRepository.update(productId, data);\n  }\n\n  /**\n   * Delete product\n   */\n  async deleteProduct(productId: string): Promise<void> {\n    await this.productRepository.delete(productId);\n  }\n\n  /**\n   * Publish product (make it active)\n   */\n  async publishProduct(productId: string): Promise<Product> {\n    return this.productRepository.update(productId, {\n      status: ProductStatus.ACTIVE,\n    });\n  }\n\n  /**\n   * Unpublish product (make it draft)\n   */\n  async unpublishProduct(productId: string): Promise<Product> {\n    return this.productRepository.update(productId, {\n      status: ProductStatus.DRAFT,\n    });\n  }\n\n  /**\n   * Update inventory\n   */\n  async updateInventory(productId: string, inventory: number): Promise<Product> {\n    if (inventory < 0) {\n      throw new BadRequestError('Inventory cannot be negative');\n    }\n\n    return this.productRepository.updateInventory(productId, inventory);\n  }\n\n  /**\n   * Reserve inventory for purchase\n   */\n  async reserveInventory(productId: string, quantity: number): Promise<Product> {\n    if (quantity <= 0) {\n      throw new BadRequestError('Quantity must be positive');\n    }\n\n    return this.productRepository.decrementInventory(productId, quantity);\n  }\n\n  /**\n   * Restock inventory\n   */\n  async restockInventory(productId: string, quantity: number): Promise<Product> {\n    if (quantity <= 0) {\n      throw new BadRequestError('Quantity must be positive');\n    }\n\n    return this.productRepository.incrementInventory(productId, quantity);\n  }\n\n  /**\n   * Get products with low stock\n   */\n  async getLowStockProducts(threshold: number = 10): Promise<Product[]> {\n    return this.productRepository.findLowStock(threshold);\n  }\n\n  /**\n   * Get products on sale\n   */\n  async getProductsOnSale(): Promise<Product[]> {\n    return this.productRepository.findOnSale();\n  }\n\n  /**\n   * Search products with filters\n   */\n  async searchProducts(\n    query: string,\n    options: SearchProductsOptions\n  ): Promise<SearchProductsResult> {\n    return this.productRepository.searchProducts(query, options);\n  }\n\n  /**\n   * Record a sale (decrement inventory and increment sold count)\n   */\n  async recordSale(productId: string, quantity: number): Promise<void> {\n    await this.productRepository.decrementInventory(productId, quantity);\n    await this.productRepository.incrementSoldCount(productId, quantity);\n  }\n\n  /**\n   * Update product rating\n   */\n  async updateProductRating(\n    productId: string,\n    newRating: number,\n    reviewCount: number\n  ): Promise<Product> {\n    // Validate rating\n    if (newRating < 1 || newRating > 5) {\n      throw new BadRequestError('Rating must be between 1 and 5');\n    }\n\n    // Get current product to calculate new average\n    const product = await this.productRepository.findById(productId);\n\n    // Calculate new average rating\n    const totalRating = product.rating * product.reviewCount + newRating * reviewCount;\n    const totalReviews = product.reviewCount + reviewCount;\n    const newAverageRating = totalRating / totalReviews;\n\n    return this.productRepository.updateRating(\n      productId,\n      Math.round(newAverageRating * 10) / 10, // Round to 1 decimal\n      totalReviews\n    );\n  }\n\n  /**\n   * Get top selling products\n   */\n  async getTopSellingProducts(limit: number = 10): Promise<Product[]> {\n    return this.productRepository.findTopSelling(limit);\n  }\n\n  /**\n   * Get top rated products\n   */\n  async getTopRatedProducts(limit: number = 10, minReviews: number = 5): Promise<Product[]> {\n    return this.productRepository.findTopRated(limit, minReviews);\n  }\n}\n"],"version":3}