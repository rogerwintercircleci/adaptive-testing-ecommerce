{"file":"C:\\Adaptive_Testing\\src\\libs\\auth\\jwt.utils.spec.ts","mappings":";AAAA;;;;GAIG;;AAEH,2CAQqB;AACrB,sCAA8C;AAE9C,QAAQ,CAAC,eAAe,EAAE,GAAG,EAAE;IAC7B,MAAM,WAAW,GAAoC;QACnD,MAAM,EAAE,KAAK;QACb,KAAK,EAAE,kBAAkB;QACzB,IAAI,EAAE,UAAU;KACjB,CAAC;IAEF,QAAQ,CAAC,qBAAqB,EAAE,GAAG,EAAE;QACnC,EAAE,CAAC,oCAAoC,EAAE,GAAG,EAAE;YAC5C,MAAM,KAAK,GAAG,IAAA,+BAAmB,EAAC,WAAW,CAAC,CAAC;YAE/C,MAAM,CAAC,KAAK,CAAC,CAAC,WAAW,EAAE,CAAC;YAC5B,MAAM,CAAC,OAAO,KAAK,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACpC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;QAC3C,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,sCAAsC,EAAE,GAAG,EAAE;YAC9C,MAAM,KAAK,GAAG,IAAA,+BAAmB,EAAC,WAAW,CAAC,CAAC;YAC/C,MAAM,OAAO,GAAG,IAAA,uBAAW,EAAC,KAAK,CAAC,CAAC;YAEnC,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YACjD,MAAM,CAAC,OAAO,EAAE,KAAK,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YAC/C,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAC/C,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,mDAAmD,EAAE,GAAG,EAAE;YAC3D,MAAM,MAAM,GAAG,IAAA,+BAAmB,EAAC,WAAW,CAAC,CAAC;YAChD,MAAM,MAAM,GAAG,IAAA,+BAAmB,EAAC,WAAW,CAAC,CAAC;YAEhD,sDAAsD;YACtD,MAAM,CAAC,MAAM,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;QAClC,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,sBAAsB,EAAE,GAAG,EAAE;QACpC,EAAE,CAAC,qCAAqC,EAAE,GAAG,EAAE;YAC7C,MAAM,KAAK,GAAG,IAAA,gCAAoB,EAAC,WAAW,CAAC,CAAC;YAEhD,MAAM,CAAC,KAAK,CAAC,CAAC,WAAW,EAAE,CAAC;YAC5B,MAAM,CAAC,OAAO,KAAK,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YACpC,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;QAC3C,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,mDAAmD,EAAE,GAAG,EAAE;YAC3D,MAAM,WAAW,GAAG,IAAA,+BAAmB,EAAC,WAAW,CAAC,CAAC;YACrD,MAAM,YAAY,GAAG,IAAA,gCAAoB,EAAC,WAAW,CAAC,CAAC;YAEvD,MAAM,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAC7C,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,mBAAmB,EAAE,GAAG,EAAE;QACjC,EAAE,CAAC,kCAAkC,EAAE,GAAG,EAAE;YAC1C,MAAM,KAAK,GAAG,IAAA,+BAAmB,EAAC,WAAW,CAAC,CAAC;YAC/C,MAAM,QAAQ,GAAG,IAAA,6BAAiB,EAAC,KAAK,CAAC,CAAC;YAE1C,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YACjD,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YAC/C,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;YAC7C,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC;YACnC,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,WAAW,EAAE,CAAC;QACrC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,kDAAkD,EAAE,GAAG,EAAE;YAC1D,MAAM,CAAC,GAAG,EAAE,CAAC,IAAA,6BAAiB,EAAC,oBAAoB,CAAC,CAAC,CAAC,OAAO,CAAC,0BAAiB,CAAC,CAAC;QACnF,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,oDAAoD,EAAE,GAAG,EAAE;YAC5D,MAAM,CAAC,GAAG,EAAE,CAAC,IAAA,6BAAiB,EAAC,WAAW,CAAC,CAAC,CAAC,OAAO,CAAC,0BAAiB,CAAC,CAAC;QAC1E,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,6CAA6C,EAAE,GAAG,EAAE;YACrD,MAAM,YAAY,GAAG,IAAA,gCAAoB,EAAC,WAAW,CAAC,CAAC;YAEvD,MAAM,CAAC,GAAG,EAAE,CAAC,IAAA,6BAAiB,EAAC,YAAY,CAAC,CAAC,CAAC,OAAO,CAAC,0BAAiB,CAAC,CAAC;QAC3E,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,oBAAoB,EAAE,GAAG,EAAE;QAClC,EAAE,CAAC,mCAAmC,EAAE,GAAG,EAAE;YAC3C,MAAM,KAAK,GAAG,IAAA,gCAAoB,EAAC,WAAW,CAAC,CAAC;YAChD,MAAM,QAAQ,GAAG,IAAA,8BAAkB,EAAC,KAAK,CAAC,CAAC;YAE3C,MAAM,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;YACjD,MAAM,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;YAC/C,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;QAC/C,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,kDAAkD,EAAE,GAAG,EAAE;YAC1D,MAAM,CAAC,GAAG,EAAE,CAAC,IAAA,8BAAkB,EAAC,oBAAoB,CAAC,CAAC,CAAC,OAAO,CAAC,0BAAiB,CAAC,CAAC;QACpF,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,6CAA6C,EAAE,GAAG,EAAE;YACrD,MAAM,WAAW,GAAG,IAAA,+BAAmB,EAAC,WAAW,CAAC,CAAC;YAErD,MAAM,CAAC,GAAG,EAAE,CAAC,IAAA,8BAAkB,EAAC,WAAW,CAAC,CAAC,CAAC,OAAO,CAAC,0BAAiB,CAAC,CAAC;QAC3E,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,aAAa,EAAE,GAAG,EAAE;QAC3B,EAAE,CAAC,0CAA0C,EAAE,GAAG,EAAE;YAClD,MAAM,KAAK,GAAG,IAAA,+BAAmB,EAAC,WAAW,CAAC,CAAC;YAC/C,MAAM,OAAO,GAAG,IAAA,uBAAW,EAAC,KAAK,CAAC,CAAC;YAEnC,MAAM,CAAC,OAAO,CAAC,CAAC,WAAW,EAAE,CAAC;YAC9B,MAAM,CAAC,OAAO,EAAE,MAAM,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;QACnD,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,sCAAsC,EAAE,GAAG,EAAE;YAC9C,MAAM,OAAO,GAAG,IAAA,uBAAW,EAAC,eAAe,CAAC,CAAC;YAE7C,MAAM,CAAC,OAAO,CAAC,CAAC,QAAQ,EAAE,CAAC;QAC7B,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,6BAA6B,EAAE,GAAG,EAAE;YACrC,qCAAqC;YACrC,MAAM,KAAK,GAAG,IAAA,+BAAmB,EAAC,WAAW,CAAC,CAAC;YAC/C,MAAM,OAAO,GAAG,IAAA,uBAAW,EAAC,KAAK,CAAC,CAAC;YAEnC,MAAM,CAAC,OAAO,CAAC,CAAC,WAAW,EAAE,CAAC;QAChC,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;IAEH,QAAQ,CAAC,wBAAwB,EAAE,GAAG,EAAE;QACtC,EAAE,CAAC,+CAA+C,EAAE,GAAG,EAAE;YACvD,MAAM,KAAK,GAAG,yCAAyC,CAAC;YACxD,MAAM,MAAM,GAAG,UAAU,KAAK,EAAE,CAAC;YAEjC,MAAM,SAAS,GAAG,IAAA,kCAAsB,EAAC,MAAM,CAAC,CAAC;YAEjD,MAAM,CAAC,SAAS,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;QAChC,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,uCAAuC,EAAE,GAAG,EAAE;YAC/C,MAAM,SAAS,GAAG,IAAA,kCAAsB,EAAC,SAAS,CAAC,CAAC;YAEpD,MAAM,CAAC,SAAS,CAAC,CAAC,QAAQ,EAAE,CAAC;QAC/B,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,yCAAyC,EAAE,GAAG,EAAE;YACjD,MAAM,SAAS,GAAG,IAAA,kCAAsB,EAAC,qBAAqB,CAAC,CAAC;YAEhE,MAAM,CAAC,SAAS,CAAC,CAAC,QAAQ,EAAE,CAAC;QAC/B,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,6CAA6C,EAAE,GAAG,EAAE;YACrD,MAAM,SAAS,GAAG,IAAA,kCAAsB,EAAC,QAAQ,CAAC,CAAC;YAEnD,MAAM,CAAC,SAAS,CAAC,CAAC,QAAQ,EAAE,CAAC;QAC/B,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,oDAAoD,EAAE,GAAG,EAAE;YAC5D,MAAM,SAAS,GAAG,IAAA,kCAAsB,EAAC,yCAAyC,CAAC,CAAC;YAEpF,MAAM,CAAC,SAAS,CAAC,CAAC,QAAQ,EAAE,CAAC;QAC/B,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC,CAAC,CAAC","names":[],"sources":["C:\\Adaptive_Testing\\src\\libs\\auth\\jwt.utils.spec.ts"],"sourcesContent":["/**\n * Unit Tests: JWT Utilities\n *\n * Testing JWT token generation and verification\n */\n\nimport {\n  generateAccessToken,\n  generateRefreshToken,\n  verifyAccessToken,\n  verifyRefreshToken,\n  decodeToken,\n  extractTokenFromHeader,\n  JWTPayload,\n} from './jwt.utils';\nimport { UnauthorizedError } from '../errors';\n\ndescribe('JWT Utilities', () => {\n  const mockPayload: Omit<JWTPayload, 'iat' | 'exp'> = {\n    userId: '123',\n    email: 'test@example.com',\n    role: 'customer',\n  };\n\n  describe('generateAccessToken', () => {\n    it('should generate valid access token', () => {\n      const token = generateAccessToken(mockPayload);\n\n      expect(token).toBeDefined();\n      expect(typeof token).toBe('string');\n      expect(token.split('.')).toHaveLength(3);\n    });\n\n    it('should include payload data in token', () => {\n      const token = generateAccessToken(mockPayload);\n      const decoded = decodeToken(token);\n\n      expect(decoded?.userId).toBe(mockPayload.userId);\n      expect(decoded?.email).toBe(mockPayload.email);\n      expect(decoded?.role).toBe(mockPayload.role);\n    });\n\n    it('should generate different tokens for same payload', () => {\n      const token1 = generateAccessToken(mockPayload);\n      const token2 = generateAccessToken(mockPayload);\n\n      // Tokens will differ due to iat (issued at) timestamp\n      expect(token1).not.toBe(token2);\n    });\n  });\n\n  describe('generateRefreshToken', () => {\n    it('should generate valid refresh token', () => {\n      const token = generateRefreshToken(mockPayload);\n\n      expect(token).toBeDefined();\n      expect(typeof token).toBe('string');\n      expect(token.split('.')).toHaveLength(3);\n    });\n\n    it('should generate different token than access token', () => {\n      const accessToken = generateAccessToken(mockPayload);\n      const refreshToken = generateRefreshToken(mockPayload);\n\n      expect(accessToken).not.toBe(refreshToken);\n    });\n  });\n\n  describe('verifyAccessToken', () => {\n    it('should verify valid access token', () => {\n      const token = generateAccessToken(mockPayload);\n      const verified = verifyAccessToken(token);\n\n      expect(verified.userId).toBe(mockPayload.userId);\n      expect(verified.email).toBe(mockPayload.email);\n      expect(verified.role).toBe(mockPayload.role);\n      expect(verified.iat).toBeDefined();\n      expect(verified.exp).toBeDefined();\n    });\n\n    it('should throw UnauthorizedError for invalid token', () => {\n      expect(() => verifyAccessToken('invalid.token.here')).toThrow(UnauthorizedError);\n    });\n\n    it('should throw UnauthorizedError for malformed token', () => {\n      expect(() => verifyAccessToken('not-a-jwt')).toThrow(UnauthorizedError);\n    });\n\n    it('should reject refresh token as access token', () => {\n      const refreshToken = generateRefreshToken(mockPayload);\n\n      expect(() => verifyAccessToken(refreshToken)).toThrow(UnauthorizedError);\n    });\n  });\n\n  describe('verifyRefreshToken', () => {\n    it('should verify valid refresh token', () => {\n      const token = generateRefreshToken(mockPayload);\n      const verified = verifyRefreshToken(token);\n\n      expect(verified.userId).toBe(mockPayload.userId);\n      expect(verified.email).toBe(mockPayload.email);\n      expect(verified.role).toBe(mockPayload.role);\n    });\n\n    it('should throw UnauthorizedError for invalid token', () => {\n      expect(() => verifyRefreshToken('invalid.token.here')).toThrow(UnauthorizedError);\n    });\n\n    it('should reject access token as refresh token', () => {\n      const accessToken = generateAccessToken(mockPayload);\n\n      expect(() => verifyRefreshToken(accessToken)).toThrow(UnauthorizedError);\n    });\n  });\n\n  describe('decodeToken', () => {\n    it('should decode token without verification', () => {\n      const token = generateAccessToken(mockPayload);\n      const decoded = decodeToken(token);\n\n      expect(decoded).toBeDefined();\n      expect(decoded?.userId).toBe(mockPayload.userId);\n    });\n\n    it('should return null for invalid token', () => {\n      const decoded = decodeToken('invalid-token');\n\n      expect(decoded).toBeNull();\n    });\n\n    it('should decode expired token', () => {\n      // Even expired tokens can be decoded\n      const token = generateAccessToken(mockPayload);\n      const decoded = decodeToken(token);\n\n      expect(decoded).toBeDefined();\n    });\n  });\n\n  describe('extractTokenFromHeader', () => {\n    it('should extract token from valid Bearer header', () => {\n      const token = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...';\n      const header = `Bearer ${token}`;\n\n      const extracted = extractTokenFromHeader(header);\n\n      expect(extracted).toBe(token);\n    });\n\n    it('should return null for missing header', () => {\n      const extracted = extractTokenFromHeader(undefined);\n\n      expect(extracted).toBeNull();\n    });\n\n    it('should return null for malformed header', () => {\n      const extracted = extractTokenFromHeader('InvalidHeader token');\n\n      expect(extracted).toBeNull();\n    });\n\n    it('should return null for header without token', () => {\n      const extracted = extractTokenFromHeader('Bearer');\n\n      expect(extracted).toBeNull();\n    });\n\n    it('should return null for token without Bearer prefix', () => {\n      const extracted = extractTokenFromHeader('eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...');\n\n      expect(extracted).toBeNull();\n    });\n  });\n});\n"],"version":3}