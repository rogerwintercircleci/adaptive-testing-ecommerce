{"file":"C:\\Adaptive_Testing\\src\\libs\\errors\\error.handler.ts","mappings":";;;AACA,6CAAyC;AACzC,6CAA0C;AAE1C;;;GAGG;AACI,MAAM,YAAY,GAAG,CAC1B,GAAU,EACV,GAAY,EACZ,GAAa,EACb,KAAmB,EACb,EAAE;IACR,IAAI,GAAG,YAAY,sBAAS,EAAE,CAAC;QAC7B,8CAA8C;QAC9C,IAAI,GAAG,CAAC,UAAU,IAAI,GAAG,EAAE,CAAC;YAC1B,eAAM,CAAC,KAAK,CAAC,mBAAmB,EAAE;gBAChC,KAAK,EAAE,GAAG,CAAC,OAAO;gBAClB,KAAK,EAAE,GAAG,CAAC,KAAK;gBAChB,UAAU,EAAE,GAAG,CAAC,UAAU;gBAC1B,IAAI,EAAE,GAAG,CAAC,IAAI;gBACd,MAAM,EAAE,GAAG,CAAC,MAAM;aACnB,CAAC,CAAC;QACL,CAAC;aAAM,CAAC;YACN,eAAM,CAAC,IAAI,CAAC,cAAc,EAAE;gBAC1B,KAAK,EAAE,GAAG,CAAC,OAAO;gBAClB,UAAU,EAAE,GAAG,CAAC,UAAU;gBAC1B,IAAI,EAAE,GAAG,CAAC,IAAI;gBACd,MAAM,EAAE,GAAG,CAAC,MAAM;aACnB,CAAC,CAAC;QACL,CAAC;QAED,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,UAAU,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC;QAC9C,OAAO;IACT,CAAC;IAED,sCAAsC;IACtC,eAAM,CAAC,KAAK,CAAC,kBAAkB,EAAE;QAC/B,KAAK,EAAE,GAAG,CAAC,OAAO;QAClB,KAAK,EAAE,GAAG,CAAC,KAAK;QAChB,IAAI,EAAE,GAAG,CAAC,IAAI;QACd,MAAM,EAAE,GAAG,CAAC,MAAM;KACnB,CAAC,CAAC;IAEH,GAAG,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC;QACnB,KAAK,EAAE,qBAAqB;QAC5B,OAAO,EAAE,8BAA8B;QACvC,UAAU,EAAE,GAAG;QACf,SAAS,EAAE,IAAI,IAAI,EAAE,CAAC,WAAW,EAAE;KACpC,CAAC,CAAC;AACL,CAAC,CAAC;AA3CW,QAAA,YAAY,gBA2CvB;AAEF;;;GAGG;AACI,MAAM,YAAY,GAAG,CAC1B,EAAyE,EACzE,EAAE;IACF,OAAO,CAAC,GAAY,EAAE,GAAa,EAAE,IAAkB,EAAQ,EAAE;QAC/D,OAAO,CAAC,OAAO,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;IAClD,CAAC,CAAC;AACJ,CAAC,CAAC;AANW,QAAA,YAAY,gBAMvB","names":[],"sources":["C:\\Adaptive_Testing\\src\\libs\\errors\\error.handler.ts"],"sourcesContent":["import { Request, Response, NextFunction } from 'express';\nimport { BaseError } from './base.error';\nimport { logger } from '../logger/logger';\n\n/**\n * Global error handler middleware\n * Catches all errors and sends appropriate responses\n */\nexport const errorHandler = (\n  err: Error,\n  req: Request,\n  res: Response,\n  _next: NextFunction\n): void => {\n  if (err instanceof BaseError) {\n    // Log operational errors at appropriate level\n    if (err.statusCode >= 500) {\n      logger.error('Operational error', {\n        error: err.message,\n        stack: err.stack,\n        statusCode: err.statusCode,\n        path: req.path,\n        method: req.method,\n      });\n    } else {\n      logger.warn('Client error', {\n        error: err.message,\n        statusCode: err.statusCode,\n        path: req.path,\n        method: req.method,\n      });\n    }\n\n    res.status(err.statusCode).json(err.toJSON());\n    return;\n  }\n\n  // Unexpected errors (not operational)\n  logger.error('Unexpected error', {\n    error: err.message,\n    stack: err.stack,\n    path: req.path,\n    method: req.method,\n  });\n\n  res.status(500).json({\n    error: 'InternalServerError',\n    message: 'An unexpected error occurred',\n    statusCode: 500,\n    timestamp: new Date().toISOString(),\n  });\n};\n\n/**\n * Async error wrapper for route handlers\n * Eliminates need for try-catch in async route handlers\n */\nexport const asyncHandler = (\n  fn: (req: Request, res: Response, next: NextFunction) => Promise<unknown>\n) => {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n"],"version":3}