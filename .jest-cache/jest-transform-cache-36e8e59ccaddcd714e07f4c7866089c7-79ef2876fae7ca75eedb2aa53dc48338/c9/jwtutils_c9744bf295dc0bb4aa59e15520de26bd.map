{"file":"C:\\Adaptive_Testing\\src\\libs\\auth\\jwt.utils.ts","mappings":"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","names":[],"sources":["C:\\Adaptive_Testing\\src\\libs\\auth\\jwt.utils.ts"],"sourcesContent":["import jwt from 'jsonwebtoken';\nimport { UnauthorizedError } from '../errors';\n\nconst JWT_SECRET = process.env.JWT_SECRET || 'your_super_secret_jwt_key';\nconst JWT_EXPIRES_IN = process.env.JWT_EXPIRES_IN || '24h';\nconst JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'your_refresh_token_secret';\nconst JWT_REFRESH_EXPIRES_IN = process.env.JWT_REFRESH_EXPIRES_IN || '7d';\n\nexport interface JWTPayload {\n  userId: string;\n  email: string;\n  role: string;\n  iat?: number;\n  exp?: number;\n}\n\n/**\n * Generate access token\n */\nexport const generateAccessToken = (payload: Omit<JWTPayload, 'iat' | 'exp'>): string => {\n  return jwt.sign(payload, JWT_SECRET, {\n    expiresIn: JWT_EXPIRES_IN,\n  } as jwt.SignOptions);\n};\n\n/**\n * Generate refresh token\n */\nexport const generateRefreshToken = (payload: Omit<JWTPayload, 'iat' | 'exp'>): string => {\n  return jwt.sign(payload, JWT_REFRESH_SECRET, {\n    expiresIn: JWT_REFRESH_EXPIRES_IN,\n  } as jwt.SignOptions);\n};\n\n/**\n * Verify access token\n * @throws UnauthorizedError if token is invalid\n */\nexport const verifyAccessToken = (token: string): JWTPayload => {\n  try {\n    return jwt.verify(token, JWT_SECRET) as JWTPayload;\n  } catch (error) {\n    if (error instanceof jwt.TokenExpiredError) {\n      throw new UnauthorizedError('Access token expired');\n    }\n    if (error instanceof jwt.JsonWebTokenError) {\n      throw new UnauthorizedError('Invalid access token');\n    }\n    throw new UnauthorizedError('Token verification failed');\n  }\n};\n\n/**\n * Verify refresh token\n * @throws UnauthorizedError if token is invalid\n */\nexport const verifyRefreshToken = (token: string): JWTPayload => {\n  try {\n    return jwt.verify(token, JWT_REFRESH_SECRET) as JWTPayload;\n  } catch (error) {\n    if (error instanceof jwt.TokenExpiredError) {\n      throw new UnauthorizedError('Refresh token expired');\n    }\n    if (error instanceof jwt.JsonWebTokenError) {\n      throw new UnauthorizedError('Invalid refresh token');\n    }\n    throw new UnauthorizedError('Token verification failed');\n  }\n};\n\n/**\n * Decode token without verification (for debugging)\n */\nexport const decodeToken = (token: string): JWTPayload | null => {\n  try {\n    return jwt.decode(token) as JWTPayload;\n  } catch {\n    return null;\n  }\n};\n\n/**\n * Extract token from Authorization header\n */\nexport const extractTokenFromHeader = (authHeader?: string): string | null => {\n  if (!authHeader) {\n    return null;\n  }\n\n  const parts = authHeader.split(' ');\n  if (parts.length !== 2 || parts[0] !== 'Bearer') {\n    return null;\n  }\n\n  return parts[1];\n};\n\n/**\n * Generate token (alias for generateAccessToken with optional custom expiry)\n */\nexport const generateToken = (\n  payload: Omit<JWTPayload, 'iat' | 'exp'>,\n  expiresIn?: string\n): string => {\n  if (expiresIn) {\n    return jwt.sign(payload, JWT_SECRET, { expiresIn } as jwt.SignOptions);\n  }\n  return generateAccessToken(payload);\n};\n\n/**\n * Verify token (alias for verifyAccessToken)\n */\nexport const verifyToken = (token: string): JWTPayload => {\n  return verifyAccessToken(token);\n};\n"],"version":3}